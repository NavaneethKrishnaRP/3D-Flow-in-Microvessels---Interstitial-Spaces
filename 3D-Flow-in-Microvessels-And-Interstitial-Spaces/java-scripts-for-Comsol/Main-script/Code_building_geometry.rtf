{\rtf1\ansi\ansicpg1252\cocoartf2822
\cocoatextscaling0\cocoaplatform0{\fonttbl\f0\fnil\fcharset0 Menlo-Regular;\f1\froman\fcharset0 TimesNewRomanPSMT;\f2\fnil\fcharset0 Menlo-Bold;
\f3\fnil\fcharset0 Menlo-Italic;}
{\colortbl;\red255\green255\blue255;\red21\green111\blue77;\red15\green112\blue16;\red0\green0\blue0;
\red205\green77\blue53;\red33\green66\blue136;\red26\green51\blue103;\red43\green43\blue43;\red14\green70\blue135;
}
{\*\expandedcolortbl;;\cssrgb\c6667\c50196\c37647;\cssrgb\c0\c50196\c7451;\cssrgb\c0\c0\c0;
\cssrgb\c84706\c38824\c26667;\cssrgb\c16863\c34118\c60392;\cssrgb\c13333\c27059\c47843;\cssrgb\c22353\c22353\c22353;\cssrgb\c4314\c35294\c60000;
}
\margl1440\margr1440\vieww11520\viewh8400\viewkind0
\deftab720
\pard\pardeftab720\partightenfactor0

\f0\fs17\fsmilli8667 \cf2 \expnd0\expndtw0\kerning0
// \cf3 Build Networks and interstitial space from the Nodal coordinates and 
\f1\fs32 \cf4 \

\f0\fs17\fsmilli8667 \cf3 // vessel radii as input and output scripts to extract WSS, average axial velocity and radial velocity
\f1\fs32 \cf4 \

\f0\fs17\fsmilli8667 \cf3 \'a0
\f1\fs32 \cf4 \

\f0\fs17\fsmilli8667 \cf3 // Written by Navaneeth Krishna Rajeeva Pandian, 3/2025
\f1\fs32 \cf4 \

\f0\fs17\fsmilli8667 \cf3 \'a0
\f1\fs32 \cf4 \

\f0\fs17\fsmilli8667 \cf3 // This script assumes all dimensions to be in um
\f1\fs32 \cf4 \

\f0\fs17\fsmilli8667 \cf3 // This script assumes that the input csv file contains nodal coordinates
\f1\fs32 \cf4 \

\f0\fs17\fsmilli8667 \cf3 // in the first six columns and vessel radius in column 7 
\f1\fs32 \cf4 \

\f0\fs17\fsmilli8667 \cf3 // This script can also be divided and used as individual methods at divisions marked by \'93//_____________\'94
\f1\fs32 \cf4 \

\f0\fs17\fsmilli8667 \cf3 \'a0
\f1\fs32 \cf4 \

\f0\fs17\fsmilli8667 \'a0
\f1\fs32 \

\f0\fs17\fsmilli8667 model.component(\cf5 "comp1"\cf4 ).geom(\cf5 "geom1"\cf4 ).lengthUnit(\cf5 "\\u00b5m"\cf4 );
\f1\fs32 \

\f0\fs17\fsmilli8667 model.component(\cf5 "comp1"\cf4 ).geom(\cf5 "geom1"\cf4 ).scaleUnitValue(
\f2\b \cf6 true
\f0\b0 \cf4 );
\f1\fs32 \

\f0\fs17\fsmilli8667 model.geom(\cf5 "geom1"\cf4 ).feature().clear();
\f1\fs32 \

\f0\fs17\fsmilli8667 \'a0
\f1\fs32 \

\f0\fs17\fsmilli8667 \cf3 // Initialize variables
\f1\fs32 \cf4 \

\f2\b\fs17\fsmilli8667 \cf7 int
\f0\b0 \cf4  i1 \cf8 =\cf4  0; 
\f2\b \cf7 int
\f0\b0 \cf4  i2 \cf8 =\cf4  0; 
\f2\b \cf7 int
\f0\b0 \cf4  i3 \cf8 =\cf4  0;
\f1\fs32 \

\f2\b\fs17\fsmilli8667 \cf7 double
\f0\b0 \cf4  rad1 \cf8 =\cf4  0.0; 
\f2\b \cf7 double
\f0\b0 \cf4  rad2 \cf8 =\cf4  0.0; 
\f1\fs32 \

\f2\b\fs17\fsmilli8667 \cf7 double
\f0\b0 \cf4  Ellipserad1 \cf8 =\cf4  0.0; 
\f2\b \cf7 double
\f0\b0 \cf4  Ellipserad2 \cf8 =\cf4  0.0;
\f1\fs32 \

\f2\b\fs17\fsmilli8667 \cf7 double
\f0\b0 \cf4  EllipseAxis \cf8 =\cf4  0.0;
\f1\fs32 \

\f2\b\fs17\fsmilli8667 \cf7 double
\f0\b0 \cf4  dist \cf8 =\cf4  0.0;
\f1\fs32 \

\f0\fs17\fsmilli8667 \cf2 \'a0
\f1\fs32 \cf4 \

\f0\fs17\fsmilli8667 \cf2 // Make sure the file importing option is ON in application builder
\f1\fs32 \cf4 \

\f3\i\fs17\fsmilli8667 \cf9 importFile
\f0\i0 \cf4 (\cf5 "file1"\cf4 );
\f1\fs32 \

\f0\fs17\fsmilli8667 String[][] D \cf8 =\cf4  
\f3\i \cf9 readCSVFile
\f0\i0 \cf4 (\cf5 "upload:///file1"\cf4 );
\f1\fs32 \

\f0\fs17\fsmilli8667 \'a0
\f1\fs32 \

\f2\b\fs17\fsmilli8667 \cf7 double
\f0\b0 \cf4 [][] dm \cf8 =\cf4  
\f2\b \cf6 new
\f0\b0 \cf4  
\f2\b \cf7 double
\f0\b0 \cf4 [D.length][9];
\f1\fs32 \

\f0\fs17\fsmilli8667 \'a0
\f1\fs32 \

\f2\b\fs17\fsmilli8667 \cf7 double
\f0\b0 \cf4  delx \cf8 =\cf4  0.0; 
\f2\b \cf7 double
\f0\b0 \cf4  dely \cf8 =\cf4  0.0; 
\f2\b \cf7 double
\f0\b0 \cf4  delz \cf8 =\cf4  0.0;
\f1\fs32 \

\f0\fs17\fsmilli8667 \'a0
\f1\fs32 \

\f2\b\fs17\fsmilli8667 \cf7 int
\f0\b0 \cf4  di1 \cf8 =\cf4  0; 
\f2\b \cf7 int
\f0\b0 \cf4  di2 \cf8 =\cf4  0;
\f1\fs32 \

\f0\fs17\fsmilli8667 \'a0
\f1\fs32 \

\f0\fs17\fsmilli8667 \cf2 // Build a block with dimensions similar to device hydrogel dimensions
\f1\fs32 \cf4 \

\f0\fs17\fsmilli8667 model.component(\cf5 "comp1"\cf4 ).geom(\cf5 "geom1"\cf4 ).create(\cf5 "blk1"\cf4 , \cf5 "Block"\cf4 );
\f1\fs32 \

\f0\fs17\fsmilli8667 model.component(\cf5 "comp1"\cf4 ).geom(\cf5 "geom1"\cf4 ).feature(\cf5 "blk1"\cf4 ).set(\cf5 "pos"\cf4 , 
\f2\b \cf6 new
\f0\b0 \cf4  
\f2\b \cf7 double
\f0\b0 \cf4 []\{453.0, 453.0, 250.0\});
\f1\fs32 \

\f0\fs17\fsmilli8667 model.component(\cf5 "comp1"\cf4 ).geom(\cf5 "geom1"\cf4 ).feature(\cf5 "blk1"\cf4 ).set(\cf5 "base"\cf4 , \cf5 "center"\cf4 );
\f1\fs32 \

\f0\fs17\fsmilli8667 model.component(\cf5 "comp1"\cf4 ).geom(\cf5 "geom1"\cf4 ).feature(\cf5 "blk1"\cf4 ).set(\cf5 "size"\cf4 , 
\f2\b \cf6 new
\f0\b0 \cf4  
\f2\b \cf7 int
\f0\b0 \cf4 []\{906, 906, 500\});
\f1\fs32 \

\f0\fs17\fsmilli8667 \'a0
\f1\fs32 \

\f2\b\fs17\fsmilli8667 \cf6 for
\f0\b0 \cf4  (
\f2\b \cf7 int
\f0\b0 \cf4  k \cf8 =\cf4  0; k \cf8 <\cf4  D.length; k\cf8 ++\cf4 ) \{
\f1\fs32 \

\f0\fs17\fsmilli8667 \'a0 
\f1\fs32 \

\f0\fs17\fsmilli8667 \'a0 \cf2 // Read the nodal coordinates and radius
\f1\fs32 \cf4 \

\f0\fs17\fsmilli8667 \'a0 dm[k][0] \cf8 =\cf4  Double.valueOf(D[k][0]);
\f1\fs32 \

\f0\fs17\fsmilli8667 \'a0 dm[k][1] \cf8 =\cf4  Double.valueOf(D[k][1]);
\f1\fs32 \

\f0\fs17\fsmilli8667 \'a0 dm[k][2] \cf8 =\cf4  Double.valueOf(D[k][2]);
\f1\fs32 \

\f0\fs17\fsmilli8667 \'a0 
\f1\fs32 \

\f0\fs17\fsmilli8667 \'a0 dm[k][3] \cf8 =\cf4  Double.valueOf(D[k][3]);
\f1\fs32 \

\f0\fs17\fsmilli8667 \'a0 dm[k][4] \cf8 =\cf4  Double.valueOf(D[k][4]);
\f1\fs32 \

\f0\fs17\fsmilli8667 \'a0 dm[k][5] \cf8 =\cf4  Double.valueOf(D[k][5]);
\f1\fs32 \

\f0\fs17\fsmilli8667 \'a0 
\f1\fs32 \

\f0\fs17\fsmilli8667 \'a0 rad1 \cf8 =\cf4  Double.valueOf(D[k][6]);\'a0 
\f1\fs32 \

\f0\fs17\fsmilli8667 \'a0 
\f1\fs32 \

\f0\fs17\fsmilli8667 \'a0 delx \cf8 =\cf4  dm[k][0]\cf8 -\cf4 dm[k][3];
\f1\fs32 \

\f0\fs17\fsmilli8667 \'a0 dely \cf8 =\cf4  dm[k][1]\cf8 -\cf4 dm[k][4];
\f1\fs32 \

\f0\fs17\fsmilli8667 \'a0 delz \cf8 =\cf4  dm[k][2]\cf8 -\cf4 dm[k][5];
\f1\fs32 \

\f0\fs17\fsmilli8667 \'a0 dist \cf8 =\cf4  \cf8 -\cf4 1\cf8 *\cf4 Math.sqrt(delx\cf8 *\cf4 delx\cf8 +\cf4 dely\cf8 *\cf4 dely\cf8 +\cf4 delz\cf8 *\cf4 delz);
\f1\fs32 \

\f0\fs17\fsmilli8667 \'a0 
\f1\fs32 \

\f0\fs17\fsmilli8667 \'a0 
\f1\fs32 \

\f0\fs17\fsmilli8667 \'a0 
\f2\b \cf6 if
\f0\b0 \cf4  (k \cf8 ==\cf4  0)
\f1\fs32 \

\f0\fs17\fsmilli8667 \'a0 \{
\f1\fs32 \

\f0\fs17\fsmilli8667 \'a0\'a0\'a0 \cf2 //String tag = model.component("comp1").geom("geom1").feature().uniquetag("wp");
\f1\fs32 \cf4 \

\f0\fs17\fsmilli8667 \'a0\'a0\'a0 i1 \cf8 =\cf4  i1\cf8 +\cf4 1;
\f1\fs32 \

\f0\fs17\fsmilli8667 \'a0\'a0\'a0 \cf2 // Create workplane and ellipse/circle to create the circle or sphere that will be extruded
\f1\fs32 \cf4 \

\f0\fs17\fsmilli8667 \'a0\'a0\'a0 model.component(\cf5 "comp1"\cf4 ).geom(\cf5 "geom1"\cf4 ).create(\cf5 "wp"\cf8 +\cf4 i1, \cf5 "WorkPlane"\cf4 );
\f1\fs32 \

\f0\fs17\fsmilli8667 \'a0\'a0\'a0 model.component(\cf5 "comp1"\cf4 ).geom(\cf5 "geom1"\cf4 ).feature(\cf5 "wp"\cf8 +\cf4 i1).set(\cf5 "planetype"\cf4 , \cf5 "normalvector"\cf4 );
\f1\fs32 \

\f0\fs17\fsmilli8667 \'a0\'a0\'a0 model.component(\cf5 "comp1"\cf4 ).geom(\cf5 "geom1"\cf4 ).feature(\cf5 "wp"\cf8 +\cf4 i1).set(\cf5 "normalvector"\cf4 , 
\f2\b \cf6 new
\f0\b0 \cf4  
\f2\b \cf7 double
\f0\b0 \cf4 []\{delx, dely, delz\});
\f1\fs32 \

\f0\fs17\fsmilli8667 \'a0\'a0\'a0 model.component(\cf5 "comp1"\cf4 ).geom(\cf5 "geom1"\cf4 ).feature(\cf5 "wp"\cf8 +\cf4 i1).set(\cf5 "normalcoord"\cf4 , 
\f2\b \cf6 new
\f0\b0 \cf4  
\f2\b \cf7 double
\f0\b0 \cf4 []\{dm[k][0], dm[k][1], dm[k][2]\});
\f1\fs32 \

\f0\fs17\fsmilli8667 \'a0\'a0\'a0 model.component(\cf5 "comp1"\cf4 ).geom(\cf5 "geom1"\cf4 ).feature(\cf5 "wp"\cf8 +\cf4 i1).set(\cf5 "unite"\cf4 , 
\f2\b \cf6 true
\f0\b0 \cf4 );
\f1\fs32 \

\f0\fs17\fsmilli8667 \'a0\'a0\'a0 model.component(\cf5 "comp1"\cf4 ).geom(\cf5 "geom1"\cf4 ).feature(\cf5 "wp"\cf8 +\cf4 i1).set(\cf5 "workplane3d"\cf4 , 
\f2\b \cf6 true
\f0\b0 \cf4 );
\f1\fs32 \

\f0\fs17\fsmilli8667 \'a0\'a0\'a0 model.component(\cf5 "comp1"\cf4 ).geom(\cf5 "geom1"\cf4 ).feature(\cf5 "wp"\cf8 +\cf4 i1).geom().create(\cf5 "c"\cf8 +\cf4 i1, \cf5 "Circle"\cf4 );
\f1\fs32 \

\f0\fs17\fsmilli8667 \'a0\'a0\'a0 model.component(\cf5 "comp1"\cf4 ).geom(\cf5 "geom1"\cf4 ).feature(\cf5 "wp"\cf8 +\cf4 i1).geom().feature(\cf5 "c"\cf8 +\cf4 i1).set(\cf5 "r"\cf4 , rad1);
\f1\fs32 \

\f0\fs17\fsmilli8667 \'a0\'a0\'a0 \cf2 //model.component("comp1").geom("geom1").run();
\f1\fs32 \cf4 \

\f0\fs17\fsmilli8667 \'a0\'a0\'a0 
\f1\fs32 \

\f0\fs17\fsmilli8667 \'a0\'a0\'a0 \cf2 // Creating the coordinate points for cylinder axis
\f1\fs32 \cf4 \

\f0\fs17\fsmilli8667 \'a0\'a0\'a0 i2 \cf8 =\cf4  i2\cf8 +\cf4 1;
\f1\fs32 \

\f0\fs17\fsmilli8667 \'a0\'a0\'a0 model.component(\cf5 "comp1"\cf4 ).geom(\cf5 "geom1"\cf4 ).create(\cf5 "ls"\cf8 +\cf4 i2, \cf5 "LineSegment"\cf4 );
\f1\fs32 \

\f0\fs17\fsmilli8667 \'a0\'a0\'a0 model.component(\cf5 "comp1"\cf4 ).geom(\cf5 "geom1"\cf4 ).feature(\cf5 "ls"\cf8 +\cf4 i2).set(\cf5 "specify1"\cf4 , \cf5 "coord"\cf4 );
\f1\fs32 \

\f0\fs17\fsmilli8667 \'a0\'a0\'a0 model.component(\cf5 "comp1"\cf4 ).geom(\cf5 "geom1"\cf4 ).feature(\cf5 "ls"\cf8 +\cf4 i2).set(\cf5 "coord1"\cf4 , 
\f2\b \cf6 new
\f0\b0 \cf4  
\f2\b \cf7 double
\f0\b0 \cf4 []\{dm[k][0], dm[k][1], dm[k][2]\});
\f1\fs32 \

\f0\fs17\fsmilli8667 \'a0\'a0\'a0 model.component(\cf5 "comp1"\cf4 ).geom(\cf5 "geom1"\cf4 ).feature(\cf5 "ls"\cf8 +\cf4 i2).set(\cf5 "specify2"\cf4 , \cf5 "coord"\cf4 );
\f1\fs32 \

\f0\fs17\fsmilli8667 \'a0\'a0\'a0 model.component(\cf5 "comp1"\cf4 ).geom(\cf5 "geom1"\cf4 ).feature(\cf5 "ls"\cf8 +\cf4 i2).set(\cf5 "coord2"\cf4 , 
\f2\b \cf6 new
\f0\b0 \cf4  
\f2\b \cf7 double
\f0\b0 \cf4 []\{dm[k][3], dm[k][4], dm[k][5]\});
\f1\fs32 \

\f0\fs17\fsmilli8667 \'a0\'a0\'a0 \cf2 //model.component("comp1").geom("geom1").run();
\f1\fs32 \cf4 \

\f0\fs17\fsmilli8667 \'a0\'a0\'a0 
\f1\fs32 \

\f0\fs17\fsmilli8667 \'a0\'a0\'a0 \cf2 // sweep the ellipse/circle along the axis
\f1\fs32 \cf4 \

\f0\fs17\fsmilli8667 \'a0\'a0\'a0 model.component(\cf5 "comp1"\cf4 ).geom(\cf5 "geom1"\cf4 ).create(\cf5 "swe"\cf8 +\cf4 i2, \cf5 "Sweep"\cf4 );
\f1\fs32 \

\f0\fs17\fsmilli8667 \'a0\'a0\'a0 model.component(\cf5 "comp1"\cf4 ).geom(\cf5 "geom1"\cf4 ).feature(\cf5 "swe"\cf8 +\cf4 i2).set(\cf5 "crossfaces"\cf4 , 
\f2\b \cf6 true
\f0\b0 \cf4 );
\f1\fs32 \

\f0\fs17\fsmilli8667 \'a0\'a0\'a0 model.component(\cf5 "comp1"\cf4 ).geom(\cf5 "geom1"\cf4 ).feature(\cf5 "swe"\cf8 +\cf4 i2).set(\cf5 "includefinal"\cf4 , 
\f2\b \cf6 false
\f0\b0 \cf4 );
\f1\fs32 \

\f0\fs17\fsmilli8667 \'a0\'a0\'a0 model.component(\cf5 "comp1"\cf4 ).geom(\cf5 "geom1"\cf4 ).feature(\cf5 "swe"\cf8 +\cf4 i2).selection(\cf5 "face"\cf4 ).set(\cf5 "wp"\cf8 +\cf4 i1\cf8 +\cf5 ".c"\cf8 +\cf4 i1, 1);
\f1\fs32 \

\f0\fs17\fsmilli8667 \'a0\'a0\'a0 model.component(\cf5 "comp1"\cf4 ).geom(\cf5 "geom1"\cf4 ).feature(\cf5 "swe"\cf8 +\cf4 i2).selection(\cf5 "edge"\cf4 ).set(\cf5 "ls"\cf8 +\cf4 i2\cf8 +\cf5 "(1)"\cf4 , 1);
\f1\fs32 \

\f0\fs17\fsmilli8667 \'a0\'a0\'a0 model.component(\cf5 "comp1"\cf4 ).geom(\cf5 "geom1"\cf4 ).feature(\cf5 "swe"\cf8 +\cf4 i2).selection(\cf5 "diredge"\cf4 ).set(\cf5 "ls"\cf8 +\cf4 i2\cf8 +\cf5 "(1)"\cf4 , 1);
\f1\fs32 \

\f0\fs17\fsmilli8667 \'a0\'a0\'a0 \cf2 //model.component("comp1").geom("geom1").run();
\f1\fs32 \cf4 \

\f0\fs17\fsmilli8667 \'a0\'a0\'a0 
\f1\fs32 \

\f0\fs17\fsmilli8667 \'a0\'a0\'a0 \cf2 // Boolean subtract sweep from the block
\f1\fs32 \cf4 \

\f0\fs17\fsmilli8667 \'a0\'a0\'a0 di1 \cf8 =\cf4  di1\cf8 +\cf4 1;
\f1\fs32 \

\f0\fs17\fsmilli8667 \'a0\'a0\'a0 model.component(\cf5 "comp1"\cf4 ).geom(\cf5 "geom1"\cf4 ).create(\cf5 "dif"\cf8 +\cf4 di1, \cf5 "Difference"\cf4 );
\f1\fs32 \

\f0\fs17\fsmilli8667 \'a0\'a0\'a0 model.component(\cf5 "comp1"\cf4 ).geom(\cf5 "geom1"\cf4 ).feature(\cf5 "dif"\cf8 +\cf4 di1).set(\cf5 "intbnd"\cf4 , 
\f2\b \cf6 false
\f0\b0 \cf4 );
\f1\fs32 \

\f0\fs17\fsmilli8667 \'a0\'a0\'a0 model.component(\cf5 "comp1"\cf4 ).geom(\cf5 "geom1"\cf4 ).feature(\cf5 "dif"\cf8 +\cf4 di1).selection(\cf5 "input"\cf4 ).set(\cf5 "blk1"\cf4 );
\f1\fs32 \

\f0\fs17\fsmilli8667 \'a0\'a0\'a0 model.component(\cf5 "comp1"\cf4 ).geom(\cf5 "geom1"\cf4 ).feature(\cf5 "dif"\cf8 +\cf4 di1).selection(\cf5 "input2"\cf4 ).set(\cf5 "swe"\cf8 +\cf4 i2);
\f1\fs32 \

\f0\fs17\fsmilli8667 \'a0\'a0\'a0 
\f1\fs32 \

\f0\fs17\fsmilli8667 \'a0\'a0\'a0 \cf2 //create an ellipsoid/sphere at the end of the sweep
\f1\fs32 \cf4 \

\f0\fs17\fsmilli8667 \'a0\'a0\'a0 i3 \cf8 =\cf4  i3\cf8 +\cf4 1;
\f1\fs32 \

\f0\fs17\fsmilli8667 \'a0\'a0\'a0 model.component(\cf5 "comp1"\cf4 ).geom(\cf5 "geom1"\cf4 ).create(\cf5 "sph"\cf8 +\cf4 i3, \cf5 "Sphere"\cf4 );
\f1\fs32 \

\f0\fs17\fsmilli8667 \'a0\'a0\'a0 model.component(\cf5 "comp1"\cf4 ).geom(\cf5 "geom1"\cf4 ).feature(\cf5 "sph"\cf8 +\cf4 i3).set(\cf5 "pos"\cf4 , 
\f2\b \cf6 new
\f0\b0 \cf4  
\f2\b \cf7 double
\f0\b0 \cf4 []\{dm[k][0], dm[k][1], dm[k][2]\});
\f1\fs32 \

\f0\fs17\fsmilli8667 \'a0\'a0\'a0 model.component(\cf5 "comp1"\cf4 ).geom(\cf5 "geom1"\cf4 ).feature(\cf5 "sph"\cf8 +\cf4 i3).set(\cf5 "axis"\cf4 , 
\f2\b \cf6 new
\f0\b0 \cf4  
\f2\b \cf7 double
\f0\b0 \cf4 []\{delx, dely, delz\});
\f1\fs32 \

\f0\fs17\fsmilli8667 \'a0\'a0\'a0 model.component(\cf5 "comp1"\cf4 ).geom(\cf5 "geom1"\cf4 ).feature(\cf5 "sph"\cf8 +\cf4 i3).set(\cf5 "r"\cf4 , rad1);
\f1\fs32 \

\f0\fs17\fsmilli8667 \'a0\'a0\'a0 
\f1\fs32 \

\f0\fs17\fsmilli8667 \'a0\'a0\'a0 \cf2 // Boolean subtract ellipsoid/sphere from the block
\f1\fs32 \cf4 \

\f0\fs17\fsmilli8667 \'a0\'a0\'a0 di1 \cf8 =\cf4  di1\cf8 +\cf4 1;
\f1\fs32 \

\f0\fs17\fsmilli8667 \'a0\'a0\'a0 di2 \cf8 =\cf4  di2\cf8 +\cf4 1;
\f1\fs32 \

\f0\fs17\fsmilli8667 \'a0\'a0\'a0 model.component(\cf5 "comp1"\cf4 ).geom(\cf5 "geom1"\cf4 ).create(\cf5 "dif"\cf8 +\cf4 di1, \cf5 "Difference"\cf4 );
\f1\fs32 \

\f0\fs17\fsmilli8667 \'a0\'a0\'a0 model.component(\cf5 "comp1"\cf4 ).geom(\cf5 "geom1"\cf4 ).feature(\cf5 "dif"\cf8 +\cf4 di1).set(\cf5 "intbnd"\cf4 , 
\f2\b \cf6 false
\f0\b0 \cf4 );
\f1\fs32 \

\f0\fs17\fsmilli8667 \'a0\'a0\'a0 model.component(\cf5 "comp1"\cf4 ).geom(\cf5 "geom1"\cf4 ).feature(\cf5 "dif"\cf8 +\cf4 di1).selection(\cf5 "input"\cf4 ).set(\cf5 "dif"\cf8 +\cf4 di2);
\f1\fs32 \

\f0\fs17\fsmilli8667 \'a0\'a0\'a0 model.component(\cf5 "comp1"\cf4 ).geom(\cf5 "geom1"\cf4 ).feature(\cf5 "dif"\cf8 +\cf4 di1).selection(\cf5 "input2"\cf4 ).set(\cf5 "sph"\cf8 +\cf4 i3);
\f1\fs32 \

\f0\fs17\fsmilli8667 \'a0\'a0\'a0 
\f1\fs32 \

\f0\fs17\fsmilli8667 \'a0\'a0\'a0 \cf2 //create an ellipsoid/sphere at the other end of the sweep
\f1\fs32 \cf4 \

\f0\fs17\fsmilli8667 \'a0\'a0\'a0 i3 \cf8 =\cf4  i3\cf8 +\cf4 1;
\f1\fs32 \

\f0\fs17\fsmilli8667 \'a0\'a0\'a0 model.component(\cf5 "comp1"\cf4 ).geom(\cf5 "geom1"\cf4 ).create(\cf5 "sph"\cf8 +\cf4 i3, \cf5 "Sphere"\cf4 );
\f1\fs32 \

\f0\fs17\fsmilli8667 \'a0\'a0\'a0 model.component(\cf5 "comp1"\cf4 ).geom(\cf5 "geom1"\cf4 ).feature(\cf5 "sph"\cf8 +\cf4 i3).set(\cf5 "pos"\cf4 , 
\f2\b \cf6 new
\f0\b0 \cf4  
\f2\b \cf7 double
\f0\b0 \cf4 []\{dm[k][3], dm[k][4], dm[k][5]\});
\f1\fs32 \

\f0\fs17\fsmilli8667 \'a0\'a0\'a0 model.component(\cf5 "comp1"\cf4 ).geom(\cf5 "geom1"\cf4 ).feature(\cf5 "sph"\cf8 +\cf4 i3).set(\cf5 "axis"\cf4 , 
\f2\b \cf6 new
\f0\b0 \cf4  
\f2\b \cf7 double
\f0\b0 \cf4 []\{delx, dely, delz\});
\f1\fs32 \

\f0\fs17\fsmilli8667 \'a0\'a0\'a0 model.component(\cf5 "comp1"\cf4 ).geom(\cf5 "geom1"\cf4 ).feature(\cf5 "sph"\cf8 +\cf4 i3).set(\cf5 "r"\cf4 , rad1);
\f1\fs32 \

\f0\fs17\fsmilli8667 \'a0\'a0\'a0 
\f1\fs32 \

\f0\fs17\fsmilli8667 \'a0\'a0\'a0 \cf2 // Boolean subtract ellipsoid/sphere from the block
\f1\fs32 \cf4 \

\f0\fs17\fsmilli8667 \'a0\'a0\'a0 di1 \cf8 =\cf4  di1\cf8 +\cf4 1;
\f1\fs32 \

\f0\fs17\fsmilli8667 \'a0\'a0\'a0 di2 \cf8 =\cf4  di2\cf8 +\cf4 1;
\f1\fs32 \

\f0\fs17\fsmilli8667 \'a0\'a0\'a0 model.component(\cf5 "comp1"\cf4 ).geom(\cf5 "geom1"\cf4 ).create(\cf5 "dif"\cf8 +\cf4 di1, \cf5 "Difference"\cf4 );
\f1\fs32 \

\f0\fs17\fsmilli8667 \'a0\'a0\'a0 model.component(\cf5 "comp1"\cf4 ).geom(\cf5 "geom1"\cf4 ).feature(\cf5 "dif"\cf8 +\cf4 di1).set(\cf5 "intbnd"\cf4 , 
\f2\b \cf6 false
\f0\b0 \cf4 );
\f1\fs32 \

\f0\fs17\fsmilli8667 \'a0\'a0\'a0 model.component(\cf5 "comp1"\cf4 ).geom(\cf5 "geom1"\cf4 ).feature(\cf5 "dif"\cf8 +\cf4 di1).selection(\cf5 "input"\cf4 ).set(\cf5 "dif"\cf8 +\cf4 di2);
\f1\fs32 \

\f0\fs17\fsmilli8667 \'a0\'a0\'a0 model.component(\cf5 "comp1"\cf4 ).geom(\cf5 "geom1"\cf4 ).feature(\cf5 "dif"\cf8 +\cf4 di1).selection(\cf5 "input2"\cf4 ).set(\cf5 "sph"\cf8 +\cf4 i3);
\f1\fs32 \

\f0\fs17\fsmilli8667 \'a0\'a0\'a0 
\f1\fs32 \

\f0\fs17\fsmilli8667 \'a0 \}
\f1\fs32 \

\f0\fs17\fsmilli8667 \'a0 
\f1\fs32 \

\f0\fs17\fsmilli8667 \'a0 
\f2\b \cf6 if
\f0\b0 \cf4  (k \cf8 >\cf4  0) \{
\f1\fs32 \

\f0\fs17\fsmilli8667 \'a0\'a0\'a0 \cf2 //String tag = model.component("comp1").geom("geom1").feature().uniquetag("wp");
\f1\fs32 \cf4 \

\f0\fs17\fsmilli8667 \'a0\'a0\'a0 i1 \cf8 =\cf4  i1\cf8 +\cf4 1;
\f1\fs32 \

\f0\fs17\fsmilli8667 \'a0\'a0\'a0 \cf2 // Create workplane and ellipse/circle to create the circle or sphere that will be extruded
\f1\fs32 \cf4 \

\f0\fs17\fsmilli8667 \'a0\'a0\'a0 model.component(\cf5 "comp1"\cf4 ).geom(\cf5 "geom1"\cf4 ).create(\cf5 "wp"\cf8 +\cf4 i1, \cf5 "WorkPlane"\cf4 );
\f1\fs32 \

\f0\fs17\fsmilli8667 \'a0\'a0\'a0 model.component(\cf5 "comp1"\cf4 ).geom(\cf5 "geom1"\cf4 ).feature(\cf5 "wp"\cf8 +\cf4 i1).set(\cf5 "planetype"\cf4 , \cf5 "normalvector"\cf4 );
\f1\fs32 \

\f0\fs17\fsmilli8667 \'a0\'a0\'a0 model.component(\cf5 "comp1"\cf4 ).geom(\cf5 "geom1"\cf4 ).feature(\cf5 "wp"\cf8 +\cf4 i1).set(\cf5 "normalvector"\cf4 , 
\f2\b \cf6 new
\f0\b0 \cf4  
\f2\b \cf7 double
\f0\b0 \cf4 []\{delx, dely, delz\});
\f1\fs32 \

\f0\fs17\fsmilli8667 \'a0\'a0\'a0 model.component(\cf5 "comp1"\cf4 ).geom(\cf5 "geom1"\cf4 ).feature(\cf5 "wp"\cf8 +\cf4 i1).set(\cf5 "normalcoord"\cf4 , 
\f2\b \cf6 new
\f0\b0 \cf4  
\f2\b \cf7 double
\f0\b0 \cf4 []\{dm[k][0], dm[k][1], dm[k][2]\});
\f1\fs32 \

\f0\fs17\fsmilli8667 \'a0\'a0\'a0 model.component(\cf5 "comp1"\cf4 ).geom(\cf5 "geom1"\cf4 ).feature(\cf5 "wp"\cf8 +\cf4 i1).set(\cf5 "unite"\cf4 , 
\f2\b \cf6 true
\f0\b0 \cf4 );
\f1\fs32 \

\f0\fs17\fsmilli8667 \'a0\'a0\'a0 model.component(\cf5 "comp1"\cf4 ).geom(\cf5 "geom1"\cf4 ).feature(\cf5 "wp"\cf8 +\cf4 i1).set(\cf5 "workplane3d"\cf4 , 
\f2\b \cf6 true
\f0\b0 \cf4 );
\f1\fs32 \

\f0\fs17\fsmilli8667 \'a0\'a0\'a0 model.component(\cf5 "comp1"\cf4 ).geom(\cf5 "geom1"\cf4 ).feature(\cf5 "wp"\cf8 +\cf4 i1).geom().create(\cf5 "c"\cf8 +\cf4 i1, \cf5 "Circle"\cf4 );
\f1\fs32 \

\f0\fs17\fsmilli8667 \'a0\'a0\'a0 model.component(\cf5 "comp1"\cf4 ).geom(\cf5 "geom1"\cf4 ).feature(\cf5 "wp"\cf8 +\cf4 i1).geom().feature(\cf5 "c"\cf8 +\cf4 i1).set(\cf5 "r"\cf4 , rad1);
\f1\fs32 \

\f0\fs17\fsmilli8667 \'a0\'a0\'a0 \cf2 //model.component("comp1").geom("geom1").run();
\f1\fs32 \cf4 \

\f0\fs17\fsmilli8667 \'a0\'a0\'a0 
\f1\fs32 \

\f0\fs17\fsmilli8667 \'a0\'a0\'a0 \cf2 // Creating the coordinate points for cylinder axis
\f1\fs32 \cf4 \

\f0\fs17\fsmilli8667 \'a0\'a0\'a0 i2 \cf8 =\cf4  i2\cf8 +\cf4 1;
\f1\fs32 \

\f0\fs17\fsmilli8667 \'a0\'a0\'a0 model.component(\cf5 "comp1"\cf4 ).geom(\cf5 "geom1"\cf4 ).create(\cf5 "ls"\cf8 +\cf4 i2, \cf5 "LineSegment"\cf4 );
\f1\fs32 \

\f0\fs17\fsmilli8667 \'a0\'a0\'a0 model.component(\cf5 "comp1"\cf4 ).geom(\cf5 "geom1"\cf4 ).feature(\cf5 "ls"\cf8 +\cf4 i2).set(\cf5 "specify1"\cf4 , \cf5 "coord"\cf4 );
\f1\fs32 \

\f0\fs17\fsmilli8667 \'a0\'a0\'a0 model.component(\cf5 "comp1"\cf4 ).geom(\cf5 "geom1"\cf4 ).feature(\cf5 "ls"\cf8 +\cf4 i2).set(\cf5 "coord1"\cf4 , 
\f2\b \cf6 new
\f0\b0 \cf4  
\f2\b \cf7 double
\f0\b0 \cf4 []\{dm[k][0], dm[k][1], dm[k][2]\});
\f1\fs32 \

\f0\fs17\fsmilli8667 \'a0\'a0\'a0 model.component(\cf5 "comp1"\cf4 ).geom(\cf5 "geom1"\cf4 ).feature(\cf5 "ls"\cf8 +\cf4 i2).set(\cf5 "specify2"\cf4 , \cf5 "coord"\cf4 );
\f1\fs32 \

\f0\fs17\fsmilli8667 \'a0\'a0\'a0 model.component(\cf5 "comp1"\cf4 ).geom(\cf5 "geom1"\cf4 ).feature(\cf5 "ls"\cf8 +\cf4 i2).set(\cf5 "coord2"\cf4 , 
\f2\b \cf6 new
\f0\b0 \cf4  
\f2\b \cf7 double
\f0\b0 \cf4 []\{dm[k][3], dm[k][4], dm[k][5]\});
\f1\fs32 \

\f0\fs17\fsmilli8667 \'a0\'a0\'a0 \cf2 //model.component("comp1").geom("geom1").run();
\f1\fs32 \cf4 \

\f0\fs17\fsmilli8667 \'a0\'a0\'a0 
\f1\fs32 \

\f0\fs17\fsmilli8667 \'a0\'a0\'a0 \cf2 // sweep the ellipse/circle along the axis
\f1\fs32 \cf4 \

\f0\fs17\fsmilli8667 \'a0\'a0\'a0 model.component(\cf5 "comp1"\cf4 ).geom(\cf5 "geom1"\cf4 ).create(\cf5 "swe"\cf8 +\cf4 i2, \cf5 "Sweep"\cf4 );
\f1\fs32 \

\f0\fs17\fsmilli8667 \'a0\'a0\'a0 model.component(\cf5 "comp1"\cf4 ).geom(\cf5 "geom1"\cf4 ).feature(\cf5 "swe"\cf8 +\cf4 i2).set(\cf5 "crossfaces"\cf4 , 
\f2\b \cf6 true
\f0\b0 \cf4 );
\f1\fs32 \

\f0\fs17\fsmilli8667 \'a0\'a0\'a0 model.component(\cf5 "comp1"\cf4 ).geom(\cf5 "geom1"\cf4 ).feature(\cf5 "swe"\cf8 +\cf4 i2).set(\cf5 "includefinal"\cf4 , 
\f2\b \cf6 false
\f0\b0 \cf4 );
\f1\fs32 \

\f0\fs17\fsmilli8667 \'a0\'a0\'a0 model.component(\cf5 "comp1"\cf4 ).geom(\cf5 "geom1"\cf4 ).feature(\cf5 "swe"\cf8 +\cf4 i2).selection(\cf5 "face"\cf4 ).set(\cf5 "wp"\cf8 +\cf4 i1\cf8 +\cf5 ".c"\cf8 +\cf4 i1, 1);
\f1\fs32 \

\f0\fs17\fsmilli8667 \'a0\'a0\'a0 model.component(\cf5 "comp1"\cf4 ).geom(\cf5 "geom1"\cf4 ).feature(\cf5 "swe"\cf8 +\cf4 i2).selection(\cf5 "edge"\cf4 ).set(\cf5 "ls"\cf8 +\cf4 i2\cf8 +\cf5 "(1)"\cf4 , 1);
\f1\fs32 \

\f0\fs17\fsmilli8667 \'a0\'a0\'a0 model.component(\cf5 "comp1"\cf4 ).geom(\cf5 "geom1"\cf4 ).feature(\cf5 "swe"\cf8 +\cf4 i2).selection(\cf5 "diredge"\cf4 ).set(\cf5 "ls"\cf8 +\cf4 i2\cf8 +\cf5 "(1)"\cf4 , 1);
\f1\fs32 \

\f0\fs17\fsmilli8667 \'a0\'a0\'a0 \cf2 //model.component("comp1").geom("geom1").run();
\f1\fs32 \cf4 \

\f0\fs17\fsmilli8667 \'a0\'a0\'a0 
\f1\fs32 \

\f0\fs17\fsmilli8667 \'a0\'a0\'a0 \cf2 // Boolean subtract sweep from the block
\f1\fs32 \cf4 \

\f0\fs17\fsmilli8667 \'a0\'a0\'a0 di1 \cf8 =\cf4  di1\cf8 +\cf4 1;
\f1\fs32 \

\f0\fs17\fsmilli8667 \'a0\'a0\'a0 di2 \cf8 =\cf4  di2\cf8 +\cf4 1;
\f1\fs32 \

\f0\fs17\fsmilli8667 \'a0\'a0\'a0 model.component(\cf5 "comp1"\cf4 ).geom(\cf5 "geom1"\cf4 ).create(\cf5 "dif"\cf8 +\cf4 di1, \cf5 "Difference"\cf4 );
\f1\fs32 \

\f0\fs17\fsmilli8667 \'a0\'a0\'a0 model.component(\cf5 "comp1"\cf4 ).geom(\cf5 "geom1"\cf4 ).feature(\cf5 "dif"\cf8 +\cf4 di1).set(\cf5 "intbnd"\cf4 , 
\f2\b \cf6 false
\f0\b0 \cf4 );
\f1\fs32 \

\f0\fs17\fsmilli8667 \'a0\'a0\'a0 model.component(\cf5 "comp1"\cf4 ).geom(\cf5 "geom1"\cf4 ).feature(\cf5 "dif"\cf8 +\cf4 di1).selection(\cf5 "input"\cf4 ).set(\cf5 "dif"\cf8 +\cf4 di2);
\f1\fs32 \

\f0\fs17\fsmilli8667 \'a0\'a0\'a0 model.component(\cf5 "comp1"\cf4 ).geom(\cf5 "geom1"\cf4 ).feature(\cf5 "dif"\cf8 +\cf4 di1).selection(\cf5 "input2"\cf4 ).set(\cf5 "swe"\cf8 +\cf4 i2);
\f1\fs32 \

\f0\fs17\fsmilli8667 \'a0\'a0\'a0 
\f1\fs32 \

\f0\fs17\fsmilli8667 \'a0\'a0\'a0 \cf2 //create an ellipsoid/sphere at the end of the sweep
\f1\fs32 \cf4 \

\f0\fs17\fsmilli8667 \'a0\'a0\'a0 i3 \cf8 =\cf4  i3\cf8 +\cf4 1;
\f1\fs32 \

\f0\fs17\fsmilli8667 \'a0\'a0\'a0 model.component(\cf5 "comp1"\cf4 ).geom(\cf5 "geom1"\cf4 ).create(\cf5 "sph"\cf8 +\cf4 i3, \cf5 "Sphere"\cf4 );
\f1\fs32 \

\f0\fs17\fsmilli8667 \'a0\'a0\'a0 model.component(\cf5 "comp1"\cf4 ).geom(\cf5 "geom1"\cf4 ).feature(\cf5 "sph"\cf8 +\cf4 i3).set(\cf5 "pos"\cf4 , 
\f2\b \cf6 new
\f0\b0 \cf4  
\f2\b \cf7 double
\f0\b0 \cf4 []\{dm[k][0], dm[k][1], dm[k][2]\});
\f1\fs32 \

\f0\fs17\fsmilli8667 \'a0\'a0\'a0 model.component(\cf5 "comp1"\cf4 ).geom(\cf5 "geom1"\cf4 ).feature(\cf5 "sph"\cf8 +\cf4 i3).set(\cf5 "axis"\cf4 , 
\f2\b \cf6 new
\f0\b0 \cf4  
\f2\b \cf7 double
\f0\b0 \cf4 []\{delx, dely, delz\});
\f1\fs32 \

\f0\fs17\fsmilli8667 \'a0\'a0\'a0 model.component(\cf5 "comp1"\cf4 ).geom(\cf5 "geom1"\cf4 ).feature(\cf5 "sph"\cf8 +\cf4 i3).set(\cf5 "r"\cf4 , rad1);
\f1\fs32 \

\f0\fs17\fsmilli8667 \'a0\'a0\'a0 
\f1\fs32 \

\f0\fs17\fsmilli8667 \'a0\'a0\'a0 \cf2 // Boolean subtract ellipsoid/sphere from the block
\f1\fs32 \cf4 \

\f0\fs17\fsmilli8667 \'a0\'a0\'a0 di1 \cf8 =\cf4  di1\cf8 +\cf4 1;
\f1\fs32 \

\f0\fs17\fsmilli8667 \'a0\'a0\'a0 di2 \cf8 =\cf4  di2\cf8 +\cf4 1;
\f1\fs32 \

\f0\fs17\fsmilli8667 \'a0\'a0\'a0 model.component(\cf5 "comp1"\cf4 ).geom(\cf5 "geom1"\cf4 ).create(\cf5 "dif"\cf8 +\cf4 di1, \cf5 "Difference"\cf4 );
\f1\fs32 \

\f0\fs17\fsmilli8667 \'a0\'a0\'a0 model.component(\cf5 "comp1"\cf4 ).geom(\cf5 "geom1"\cf4 ).feature(\cf5 "dif"\cf8 +\cf4 di1).set(\cf5 "intbnd"\cf4 , 
\f2\b \cf6 false
\f0\b0 \cf4 );
\f1\fs32 \

\f0\fs17\fsmilli8667 \'a0\'a0\'a0 model.component(\cf5 "comp1"\cf4 ).geom(\cf5 "geom1"\cf4 ).feature(\cf5 "dif"\cf8 +\cf4 di1).selection(\cf5 "input"\cf4 ).set(\cf5 "dif"\cf8 +\cf4 di2);
\f1\fs32 \

\f0\fs17\fsmilli8667 \'a0\'a0\'a0 model.component(\cf5 "comp1"\cf4 ).geom(\cf5 "geom1"\cf4 ).feature(\cf5 "dif"\cf8 +\cf4 di1).selection(\cf5 "input2"\cf4 ).set(\cf5 "sph"\cf8 +\cf4 i3);
\f1\fs32 \

\f0\fs17\fsmilli8667 \'a0\'a0\'a0 
\f1\fs32 \

\f0\fs17\fsmilli8667 \'a0\'a0\'a0 \cf2 //create an ellipsoid/sphere at the other end of the sweep
\f1\fs32 \cf4 \

\f0\fs17\fsmilli8667 \'a0\'a0\'a0 i3 \cf8 =\cf4  i3\cf8 +\cf4 1;
\f1\fs32 \

\f0\fs17\fsmilli8667 \'a0\'a0\'a0 model.component(\cf5 "comp1"\cf4 ).geom(\cf5 "geom1"\cf4 ).create(\cf5 "sph"\cf8 +\cf4 i3, \cf5 "Sphere"\cf4 );
\f1\fs32 \

\f0\fs17\fsmilli8667 \'a0\'a0\'a0 model.component(\cf5 "comp1"\cf4 ).geom(\cf5 "geom1"\cf4 ).feature(\cf5 "sph"\cf8 +\cf4 i3).set(\cf5 "pos"\cf4 , 
\f2\b \cf6 new
\f0\b0 \cf4  
\f2\b \cf7 double
\f0\b0 \cf4 []\{dm[k][3], dm[k][4], dm[k][5]\});
\f1\fs32 \

\f0\fs17\fsmilli8667 \'a0\'a0\'a0 model.component(\cf5 "comp1"\cf4 ).geom(\cf5 "geom1"\cf4 ).feature(\cf5 "sph"\cf8 +\cf4 i3).set(\cf5 "axis"\cf4 , 
\f2\b \cf6 new
\f0\b0 \cf4  
\f2\b \cf7 double
\f0\b0 \cf4 []\{delx, dely, delz\});
\f1\fs32 \

\f0\fs17\fsmilli8667 \'a0\'a0\'a0 model.component(\cf5 "comp1"\cf4 ).geom(\cf5 "geom1"\cf4 ).feature(\cf5 "sph"\cf8 +\cf4 i3).set(\cf5 "r"\cf4 , rad1);
\f1\fs32 \

\f0\fs17\fsmilli8667 \'a0\'a0\'a0 
\f1\fs32 \

\f0\fs17\fsmilli8667 \'a0\'a0\'a0 \cf2 // Boolean subtract ellipsoid/sphere from the block
\f1\fs32 \cf4 \

\f0\fs17\fsmilli8667 \'a0\'a0\'a0 di1 \cf8 =\cf4  di1\cf8 +\cf4 1;
\f1\fs32 \

\f0\fs17\fsmilli8667 \'a0\'a0\'a0 di2 \cf8 =\cf4  di2\cf8 +\cf4 1;
\f1\fs32 \

\f0\fs17\fsmilli8667 \'a0\'a0\'a0 model.component(\cf5 "comp1"\cf4 ).geom(\cf5 "geom1"\cf4 ).create(\cf5 "dif"\cf8 +\cf4 di1, \cf5 "Difference"\cf4 );
\f1\fs32 \

\f0\fs17\fsmilli8667 \'a0\'a0\'a0 model.component(\cf5 "comp1"\cf4 ).geom(\cf5 "geom1"\cf4 ).feature(\cf5 "dif"\cf8 +\cf4 di1).set(\cf5 "intbnd"\cf4 , 
\f2\b \cf6 false
\f0\b0 \cf4 );
\f1\fs32 \

\f0\fs17\fsmilli8667 \'a0\'a0\'a0 model.component(\cf5 "comp1"\cf4 ).geom(\cf5 "geom1"\cf4 ).feature(\cf5 "dif"\cf8 +\cf4 di1).selection(\cf5 "input"\cf4 ).set(\cf5 "dif"\cf8 +\cf4 di2);
\f1\fs32 \

\f0\fs17\fsmilli8667 \'a0\'a0\'a0 model.component(\cf5 "comp1"\cf4 ).geom(\cf5 "geom1"\cf4 ).feature(\cf5 "dif"\cf8 +\cf4 di1).selection(\cf5 "input2"\cf4 ).set(\cf5 "sph"\cf8 +\cf4 i3);
\f1\fs32 \

\f0\fs17\fsmilli8667 \'a0\'a0\'a0 
\f1\fs32 \

\f0\fs17\fsmilli8667 \'a0 \}
\f1\fs32 \

\f0\fs17\fsmilli8667 \'a0 
\f1\fs32 \

\f0\fs17\fsmilli8667 \}
\f1\fs32 \

\f0\fs17\fsmilli8667 \'a0
\f1\fs32 \

\f0\fs17\fsmilli8667 \'a0
\f1\fs32 \

\f0\fs17\fsmilli8667 \cf2 //_____________________________________________________________________________________________________________________
\f1\fs32 \cf4 \

\f0\fs17\fsmilli8667 \cf2 // Build a second block with dimensions similar to device hydrogel dimensions this is for endo monolayer
\f1\fs32 \cf4 \

\f0\fs17\fsmilli8667 model.component(\cf5 "comp1"\cf4 ).geom(\cf5 "geom1"\cf4 ).create(\cf5 "blk2"\cf4 , \cf5 "Block"\cf4 );
\f1\fs32 \

\f0\fs17\fsmilli8667 model.component(\cf5 "comp1"\cf4 ).geom(\cf5 "geom1"\cf4 ).feature(\cf5 "blk2"\cf4 ).set(\cf5 "pos"\cf4 , 
\f2\b \cf6 new
\f0\b0 \cf4  
\f2\b \cf7 double
\f0\b0 \cf4 []\{453.0, 453.0, 250.0\});
\f1\fs32 \

\f0\fs17\fsmilli8667 model.component(\cf5 "comp1"\cf4 ).geom(\cf5 "geom1"\cf4 ).feature(\cf5 "blk2"\cf4 ).set(\cf5 "base"\cf4 , \cf5 "center"\cf4 );
\f1\fs32 \

\f0\fs17\fsmilli8667 model.component(\cf5 "comp1"\cf4 ).geom(\cf5 "geom1"\cf4 ).feature(\cf5 "blk2"\cf4 ).set(\cf5 "size"\cf4 , 
\f2\b \cf6 new
\f0\b0 \cf4  
\f2\b \cf7 int
\f0\b0 \cf4 []\{906, 906, 500\});
\f1\fs32 \

\f0\fs17\fsmilli8667 \'a0
\f1\fs32 \

\f0\fs17\fsmilli8667 \cf2 // Uncomment below lines, if used as an independent method
\f1\fs32 \cf4 \

\f0\fs17\fsmilli8667 \cf2 // importFile("file1");
\f1\fs32 \cf4 \

\f0\fs17\fsmilli8667 \cf2 // String[][] D = readCSVFile("upload:///file1");
\f1\fs32 \cf4 \

\f0\fs17\fsmilli8667 \'a0
\f1\fs32 \

\f0\fs17\fsmilli8667 \'a0
\f1\fs32 \

\f2\b\fs17\fsmilli8667 \cf6 for
\f0\b0 \cf4  (
\f2\b \cf7 int
\f0\b0 \cf4  k \cf8 =\cf4  0; k \cf8 <\cf4  D.length; k\cf8 ++\cf4 ) \{
\f1\fs32 \

\f0\fs17\fsmilli8667 \'a0 
\f1\fs32 \

\f0\fs17\fsmilli8667 \'a0 \cf2 // Read the nodal coordinates and radius
\f1\fs32 \cf4 \

\f0\fs17\fsmilli8667 \'a0 dm[k][0] \cf8 =\cf4  Double.valueOf(D[k][0]);
\f1\fs32 \

\f0\fs17\fsmilli8667 \'a0 dm[k][1] \cf8 =\cf4  Double.valueOf(D[k][1]);
\f1\fs32 \

\f0\fs17\fsmilli8667 \'a0 dm[k][2] \cf8 =\cf4  Double.valueOf(D[k][2]);
\f1\fs32 \

\f0\fs17\fsmilli8667 \'a0 
\f1\fs32 \

\f0\fs17\fsmilli8667 \'a0 dm[k][3] \cf8 =\cf4  Double.valueOf(D[k][3]);
\f1\fs32 \

\f0\fs17\fsmilli8667 \'a0 dm[k][4] \cf8 =\cf4  Double.valueOf(D[k][4]);
\f1\fs32 \

\f0\fs17\fsmilli8667 \'a0 dm[k][5] \cf8 =\cf4  Double.valueOf(D[k][5]);
\f1\fs32 \

\f0\fs17\fsmilli8667 \'a0 
\f1\fs32 \

\f0\fs17\fsmilli8667 \'a0 \cf2 // Assuming endo thickness as 10 um
\f1\fs32 \cf4 \

\f0\fs17\fsmilli8667 \'a0 rad1 \cf8 =\cf4  Double.valueOf(D[k][6])+10.0;\'a0 
\f1\fs32 \

\f0\fs17\fsmilli8667 \'a0 
\f1\fs32 \

\f0\fs17\fsmilli8667 \'a0 delx \cf8 =\cf4  dm[k][0]\cf8 -\cf4 dm[k][3];
\f1\fs32 \

\f0\fs17\fsmilli8667 \'a0 dely \cf8 =\cf4  dm[k][1]\cf8 -\cf4 dm[k][4];
\f1\fs32 \

\f0\fs17\fsmilli8667 \'a0 delz \cf8 =\cf4  dm[k][2]\cf8 -\cf4 dm[k][5];
\f1\fs32 \

\f0\fs17\fsmilli8667 \'a0 dist \cf8 =\cf4  \cf8 -\cf4 1\cf8 *\cf4 Math.sqrt(delx\cf8 *\cf4 delx\cf8 +\cf4 dely\cf8 *\cf4 dely\cf8 +\cf4 delz\cf8 *\cf4 delz);
\f1\fs32 \

\f0\fs17\fsmilli8667 \'a0 
\f1\fs32 \

\f0\fs17\fsmilli8667 \'a0 
\f1\fs32 \

\f0\fs17\fsmilli8667 \'a0 
\f2\b \cf6 if
\f0\b0 \cf4  (k \cf8 ==\cf4  0)
\f1\fs32 \

\f0\fs17\fsmilli8667 \'a0 \{
\f1\fs32 \

\f0\fs17\fsmilli8667 \'a0\'a0\'a0 \cf2 //String tag = model.component("comp1").geom("geom1").feature().uniquetag("wp");
\f1\fs32 \cf4 \

\f0\fs17\fsmilli8667 \'a0\'a0\'a0 i1 \cf8 =\cf4  i1\cf8 +\cf4 1;
\f1\fs32 \

\f0\fs17\fsmilli8667 \'a0\'a0\'a0 \cf2 // Create workplane and ellipse/circle to create the circle or sphere that will be extruded
\f1\fs32 \cf4 \

\f0\fs17\fsmilli8667 \'a0\'a0\'a0 model.component(\cf5 "comp1"\cf4 ).geom(\cf5 "geom1"\cf4 ).create(\cf5 "wp"\cf8 +\cf4 i1, \cf5 "WorkPlane"\cf4 );
\f1\fs32 \

\f0\fs17\fsmilli8667 \'a0\'a0\'a0 model.component(\cf5 "comp1"\cf4 ).geom(\cf5 "geom1"\cf4 ).feature(\cf5 "wp"\cf8 +\cf4 i1).set(\cf5 "planetype"\cf4 , \cf5 "normalvector"\cf4 );
\f1\fs32 \

\f0\fs17\fsmilli8667 \'a0\'a0\'a0 model.component(\cf5 "comp1"\cf4 ).geom(\cf5 "geom1"\cf4 ).feature(\cf5 "wp"\cf8 +\cf4 i1).set(\cf5 "normalvector"\cf4 , 
\f2\b \cf6 new
\f0\b0 \cf4  
\f2\b \cf7 double
\f0\b0 \cf4 []\{delx, dely, delz\});
\f1\fs32 \

\f0\fs17\fsmilli8667 \'a0\'a0\'a0 model.component(\cf5 "comp1"\cf4 ).geom(\cf5 "geom1"\cf4 ).feature(\cf5 "wp"\cf8 +\cf4 i1).set(\cf5 "normalcoord"\cf4 , 
\f2\b \cf6 new
\f0\b0 \cf4  
\f2\b \cf7 double
\f0\b0 \cf4 []\{dm[k][0], dm[k][1], dm[k][2]\});
\f1\fs32 \

\f0\fs17\fsmilli8667 \'a0\'a0\'a0 model.component(\cf5 "comp1"\cf4 ).geom(\cf5 "geom1"\cf4 ).feature(\cf5 "wp"\cf8 +\cf4 i1).set(\cf5 "unite"\cf4 , 
\f2\b \cf6 true
\f0\b0 \cf4 );
\f1\fs32 \

\f0\fs17\fsmilli8667 \'a0\'a0\'a0 model.component(\cf5 "comp1"\cf4 ).geom(\cf5 "geom1"\cf4 ).feature(\cf5 "wp"\cf8 +\cf4 i1).set(\cf5 "workplane3d"\cf4 , 
\f2\b \cf6 true
\f0\b0 \cf4 );
\f1\fs32 \

\f0\fs17\fsmilli8667 \'a0\'a0\'a0 model.component(\cf5 "comp1"\cf4 ).geom(\cf5 "geom1"\cf4 ).feature(\cf5 "wp"\cf8 +\cf4 i1).geom().create(\cf5 "c"\cf8 +\cf4 i1, \cf5 "Circle"\cf4 );
\f1\fs32 \

\f0\fs17\fsmilli8667 \'a0\'a0\'a0 model.component(\cf5 "comp1"\cf4 ).geom(\cf5 "geom1"\cf4 ).feature(\cf5 "wp"\cf8 +\cf4 i1).geom().feature(\cf5 "c"\cf8 +\cf4 i1).set(\cf5 "r"\cf4 , rad1);
\f1\fs32 \

\f0\fs17\fsmilli8667 \'a0\'a0\'a0 \cf2 //model.component("comp1").geom("geom1").run();
\f1\fs32 \cf4 \

\f0\fs17\fsmilli8667 \'a0\'a0\'a0 
\f1\fs32 \

\f0\fs17\fsmilli8667 \'a0\'a0\'a0 \cf2 // Creating the coordinate points for cylinder axis
\f1\fs32 \cf4 \

\f0\fs17\fsmilli8667 \'a0\'a0\'a0 i2 \cf8 =\cf4  i2\cf8 +\cf4 1;
\f1\fs32 \

\f0\fs17\fsmilli8667 \'a0\'a0\'a0 model.component(\cf5 "comp1"\cf4 ).geom(\cf5 "geom1"\cf4 ).create(\cf5 "ls"\cf8 +\cf4 i2, \cf5 "LineSegment"\cf4 );
\f1\fs32 \

\f0\fs17\fsmilli8667 \'a0\'a0\'a0 model.component(\cf5 "comp1"\cf4 ).geom(\cf5 "geom1"\cf4 ).feature(\cf5 "ls"\cf8 +\cf4 i2).set(\cf5 "specify1"\cf4 , \cf5 "coord"\cf4 );
\f1\fs32 \

\f0\fs17\fsmilli8667 \'a0\'a0\'a0 model.component(\cf5 "comp1"\cf4 ).geom(\cf5 "geom1"\cf4 ).feature(\cf5 "ls"\cf8 +\cf4 i2).set(\cf5 "coord1"\cf4 , 
\f2\b \cf6 new
\f0\b0 \cf4  
\f2\b \cf7 double
\f0\b0 \cf4 []\{dm[k][0], dm[k][1], dm[k][2]\});
\f1\fs32 \

\f0\fs17\fsmilli8667 \'a0\'a0\'a0 model.component(\cf5 "comp1"\cf4 ).geom(\cf5 "geom1"\cf4 ).feature(\cf5 "ls"\cf8 +\cf4 i2).set(\cf5 "specify2"\cf4 , \cf5 "coord"\cf4 );
\f1\fs32 \

\f0\fs17\fsmilli8667 \'a0\'a0\'a0 model.component(\cf5 "comp1"\cf4 ).geom(\cf5 "geom1"\cf4 ).feature(\cf5 "ls"\cf8 +\cf4 i2).set(\cf5 "coord2"\cf4 , 
\f2\b \cf6 new
\f0\b0 \cf4  
\f2\b \cf7 double
\f0\b0 \cf4 []\{dm[k][3], dm[k][4], dm[k][5]\});
\f1\fs32 \

\f0\fs17\fsmilli8667 \'a0\'a0\'a0 \cf2 //model.component("comp1").geom("geom1").run();
\f1\fs32 \cf4 \

\f0\fs17\fsmilli8667 \'a0\'a0\'a0 
\f1\fs32 \

\f0\fs17\fsmilli8667 \'a0\'a0\'a0 \cf2 // sweep the ellipse/circle along the axis
\f1\fs32 \cf4 \

\f0\fs17\fsmilli8667 \'a0\'a0\'a0 model.component(\cf5 "comp1"\cf4 ).geom(\cf5 "geom1"\cf4 ).create(\cf5 "swe"\cf8 +\cf4 i2, \cf5 "Sweep"\cf4 );
\f1\fs32 \

\f0\fs17\fsmilli8667 \'a0\'a0\'a0 model.component(\cf5 "comp1"\cf4 ).geom(\cf5 "geom1"\cf4 ).feature(\cf5 "swe"\cf8 +\cf4 i2).set(\cf5 "crossfaces"\cf4 , 
\f2\b \cf6 true
\f0\b0 \cf4 );
\f1\fs32 \

\f0\fs17\fsmilli8667 \'a0\'a0\'a0 model.component(\cf5 "comp1"\cf4 ).geom(\cf5 "geom1"\cf4 ).feature(\cf5 "swe"\cf8 +\cf4 i2).set(\cf5 "includefinal"\cf4 , 
\f2\b \cf6 false
\f0\b0 \cf4 );
\f1\fs32 \

\f0\fs17\fsmilli8667 \'a0\'a0\'a0 model.component(\cf5 "comp1"\cf4 ).geom(\cf5 "geom1"\cf4 ).feature(\cf5 "swe"\cf8 +\cf4 i2).selection(\cf5 "face"\cf4 ).set(\cf5 "wp"\cf8 +\cf4 i1\cf8 +\cf5 ".c"\cf8 +\cf4 i1, 1);
\f1\fs32 \

\f0\fs17\fsmilli8667 \'a0\'a0\'a0 model.component(\cf5 "comp1"\cf4 ).geom(\cf5 "geom1"\cf4 ).feature(\cf5 "swe"\cf8 +\cf4 i2).selection(\cf5 "edge"\cf4 ).set(\cf5 "ls"\cf8 +\cf4 i2\cf8 +\cf5 "(1)"\cf4 , 1);
\f1\fs32 \

\f0\fs17\fsmilli8667 \'a0\'a0\'a0 model.component(\cf5 "comp1"\cf4 ).geom(\cf5 "geom1"\cf4 ).feature(\cf5 "swe"\cf8 +\cf4 i2).selection(\cf5 "diredge"\cf4 ).set(\cf5 "ls"\cf8 +\cf4 i2\cf8 +\cf5 "(1)"\cf4 , 1);
\f1\fs32 \

\f0\fs17\fsmilli8667 \'a0\'a0\'a0 \cf2 //model.component("comp1").geom("geom1").run();
\f1\fs32 \cf4 \

\f0\fs17\fsmilli8667 \'a0\'a0\'a0 
\f1\fs32 \

\f0\fs17\fsmilli8667 \'a0\'a0\'a0 \cf2 // Boolean subtract sweep from the block
\f1\fs32 \cf4 \

\f0\fs17\fsmilli8667 \'a0\'a0\'a0 di1 \cf8 =\cf4  di1\cf8 +\cf4 1;
\f1\fs32 \

\f0\fs17\fsmilli8667 \'a0\'a0\'a0 model.component(\cf5 "comp1"\cf4 ).geom(\cf5 "geom1"\cf4 ).create(\cf5 "dif"\cf8 +\cf4 di1, \cf5 "Difference"\cf4 );
\f1\fs32 \

\f0\fs17\fsmilli8667 \'a0\'a0\'a0 model.component(\cf5 "comp1"\cf4 ).geom(\cf5 "geom1"\cf4 ).feature(\cf5 "dif"\cf8 +\cf4 di1).set(\cf5 "intbnd"\cf4 , 
\f2\b \cf6 false
\f0\b0 \cf4 );
\f1\fs32 \

\f0\fs17\fsmilli8667 \'a0\'a0\'a0 model.component(\cf5 "comp1"\cf4 ).geom(\cf5 "geom1"\cf4 ).feature(\cf5 "dif"\cf8 +\cf4 di1).selection(\cf5 "input"\cf4 ).set(\cf5 "blk2"\cf4 );
\f1\fs32 \

\f0\fs17\fsmilli8667 \'a0\'a0\'a0 model.component(\cf5 "comp1"\cf4 ).geom(\cf5 "geom1"\cf4 ).feature(\cf5 "dif"\cf8 +\cf4 di1).selection(\cf5 "input2"\cf4 ).set(\cf5 "swe"\cf8 +\cf4 i2);
\f1\fs32 \

\f0\fs17\fsmilli8667 \'a0\'a0\'a0 
\f1\fs32 \

\f0\fs17\fsmilli8667 \'a0\'a0\'a0 \cf2 //create an ellipsoid/sphere at the end of the sweep
\f1\fs32 \cf4 \

\f0\fs17\fsmilli8667 \'a0\'a0\'a0 i3 \cf8 =\cf4  i3\cf8 +\cf4 1;
\f1\fs32 \

\f0\fs17\fsmilli8667 \'a0\'a0\'a0 model.component(\cf5 "comp1"\cf4 ).geom(\cf5 "geom1"\cf4 ).create(\cf5 "sph"\cf8 +\cf4 i3, \cf5 "Sphere"\cf4 );
\f1\fs32 \

\f0\fs17\fsmilli8667 \'a0\'a0\'a0 model.component(\cf5 "comp1"\cf4 ).geom(\cf5 "geom1"\cf4 ).feature(\cf5 "sph"\cf8 +\cf4 i3).set(\cf5 "pos"\cf4 , 
\f2\b \cf6 new
\f0\b0 \cf4  
\f2\b \cf7 double
\f0\b0 \cf4 []\{dm[k][0], dm[k][1], dm[k][2]\});
\f1\fs32 \

\f0\fs17\fsmilli8667 \'a0\'a0\'a0 model.component(\cf5 "comp1"\cf4 ).geom(\cf5 "geom1"\cf4 ).feature(\cf5 "sph"\cf8 +\cf4 i3).set(\cf5 "axis"\cf4 , 
\f2\b \cf6 new
\f0\b0 \cf4  
\f2\b \cf7 double
\f0\b0 \cf4 []\{delx, dely, delz\});
\f1\fs32 \

\f0\fs17\fsmilli8667 \'a0\'a0\'a0 model.component(\cf5 "comp1"\cf4 ).geom(\cf5 "geom1"\cf4 ).feature(\cf5 "sph"\cf8 +\cf4 i3).set(\cf5 "r"\cf4 , rad1);
\f1\fs32 \

\f0\fs17\fsmilli8667 \'a0\'a0\'a0 
\f1\fs32 \

\f0\fs17\fsmilli8667 \'a0\'a0\'a0 \cf2 // Boolean subtract ellipsoid/sphere from the block
\f1\fs32 \cf4 \

\f0\fs17\fsmilli8667 \'a0\'a0\'a0 di1 \cf8 =\cf4  di1\cf8 +\cf4 1;
\f1\fs32 \

\f0\fs17\fsmilli8667 \'a0\'a0\'a0 di2 \cf8 =\cf4  di2\cf8 +\cf4 1;
\f1\fs32 \

\f0\fs17\fsmilli8667 \'a0\'a0\'a0 model.component(\cf5 "comp1"\cf4 ).geom(\cf5 "geom1"\cf4 ).create(\cf5 "dif"\cf8 +\cf4 di1, \cf5 "Difference"\cf4 );
\f1\fs32 \

\f0\fs17\fsmilli8667 \'a0\'a0\'a0 model.component(\cf5 "comp1"\cf4 ).geom(\cf5 "geom1"\cf4 ).feature(\cf5 "dif"\cf8 +\cf4 di1).set(\cf5 "intbnd"\cf4 , 
\f2\b \cf6 false
\f0\b0 \cf4 );
\f1\fs32 \

\f0\fs17\fsmilli8667 \'a0\'a0\'a0 model.component(\cf5 "comp1"\cf4 ).geom(\cf5 "geom1"\cf4 ).feature(\cf5 "dif"\cf8 +\cf4 di1).selection(\cf5 "input"\cf4 ).set(\cf5 "dif"\cf8 +\cf4 di2);
\f1\fs32 \

\f0\fs17\fsmilli8667 \'a0\'a0\'a0 model.component(\cf5 "comp1"\cf4 ).geom(\cf5 "geom1"\cf4 ).feature(\cf5 "dif"\cf8 +\cf4 di1).selection(\cf5 "input2"\cf4 ).set(\cf5 "sph"\cf8 +\cf4 i3);
\f1\fs32 \

\f0\fs17\fsmilli8667 \'a0\'a0\'a0 
\f1\fs32 \

\f0\fs17\fsmilli8667 \'a0\'a0\'a0 \cf2 //create an ellipsoid/sphere at the other end of the sweep
\f1\fs32 \cf4 \

\f0\fs17\fsmilli8667 \'a0\'a0\'a0 i3 \cf8 =\cf4  i3\cf8 +\cf4 1;
\f1\fs32 \

\f0\fs17\fsmilli8667 \'a0\'a0\'a0 model.component(\cf5 "comp1"\cf4 ).geom(\cf5 "geom1"\cf4 ).create(\cf5 "sph"\cf8 +\cf4 i3, \cf5 "Sphere"\cf4 );
\f1\fs32 \

\f0\fs17\fsmilli8667 \'a0\'a0\'a0 model.component(\cf5 "comp1"\cf4 ).geom(\cf5 "geom1"\cf4 ).feature(\cf5 "sph"\cf8 +\cf4 i3).set(\cf5 "pos"\cf4 , 
\f2\b \cf6 new
\f0\b0 \cf4  
\f2\b \cf7 double
\f0\b0 \cf4 []\{dm[k][3], dm[k][4], dm[k][5]\});
\f1\fs32 \

\f0\fs17\fsmilli8667 \'a0\'a0\'a0 model.component(\cf5 "comp1"\cf4 ).geom(\cf5 "geom1"\cf4 ).feature(\cf5 "sph"\cf8 +\cf4 i3).set(\cf5 "axis"\cf4 , 
\f2\b \cf6 new
\f0\b0 \cf4  
\f2\b \cf7 double
\f0\b0 \cf4 []\{delx, dely, delz\});
\f1\fs32 \

\f0\fs17\fsmilli8667 \'a0\'a0\'a0 model.component(\cf5 "comp1"\cf4 ).geom(\cf5 "geom1"\cf4 ).feature(\cf5 "sph"\cf8 +\cf4 i3).set(\cf5 "r"\cf4 , rad1);
\f1\fs32 \

\f0\fs17\fsmilli8667 \'a0\'a0\'a0 
\f1\fs32 \

\f0\fs17\fsmilli8667 \'a0\'a0\'a0 \cf2 // Boolean subtract ellipsoid/sphere from the block
\f1\fs32 \cf4 \

\f0\fs17\fsmilli8667 \'a0\'a0\'a0 di1 \cf8 =\cf4  di1\cf8 +\cf4 1;
\f1\fs32 \

\f0\fs17\fsmilli8667 \'a0\'a0\'a0 di2 \cf8 =\cf4  di2\cf8 +\cf4 1;
\f1\fs32 \

\f0\fs17\fsmilli8667 \'a0\'a0\'a0 model.component(\cf5 "comp1"\cf4 ).geom(\cf5 "geom1"\cf4 ).create(\cf5 "dif"\cf8 +\cf4 di1, \cf5 "Difference"\cf4 );
\f1\fs32 \

\f0\fs17\fsmilli8667 \'a0\'a0\'a0 model.component(\cf5 "comp1"\cf4 ).geom(\cf5 "geom1"\cf4 ).feature(\cf5 "dif"\cf8 +\cf4 di1).set(\cf5 "intbnd"\cf4 , 
\f2\b \cf6 false
\f0\b0 \cf4 );
\f1\fs32 \

\f0\fs17\fsmilli8667 \'a0\'a0\'a0 model.component(\cf5 "comp1"\cf4 ).geom(\cf5 "geom1"\cf4 ).feature(\cf5 "dif"\cf8 +\cf4 di1).selection(\cf5 "input"\cf4 ).set(\cf5 "dif"\cf8 +\cf4 di2);
\f1\fs32 \

\f0\fs17\fsmilli8667 \'a0\'a0\'a0 model.component(\cf5 "comp1"\cf4 ).geom(\cf5 "geom1"\cf4 ).feature(\cf5 "dif"\cf8 +\cf4 di1).selection(\cf5 "input2"\cf4 ).set(\cf5 "sph"\cf8 +\cf4 i3);
\f1\fs32 \

\f0\fs17\fsmilli8667 \'a0\'a0\'a0 
\f1\fs32 \

\f0\fs17\fsmilli8667 \'a0 \}
\f1\fs32 \

\f0\fs17\fsmilli8667 \'a0 
\f1\fs32 \

\f0\fs17\fsmilli8667 \'a0 
\f2\b \cf6 if
\f0\b0 \cf4  (k \cf8 >\cf4  0) \{
\f1\fs32 \

\f0\fs17\fsmilli8667 \'a0\'a0\'a0 \cf2 //String tag = model.component("comp1").geom("geom1").feature().uniquetag("wp");
\f1\fs32 \cf4 \

\f0\fs17\fsmilli8667 \'a0\'a0\'a0 i1 \cf8 =\cf4  i1\cf8 +\cf4 1;
\f1\fs32 \

\f0\fs17\fsmilli8667 \'a0\'a0\'a0 \cf2 // Create workplane and ellipse/circle to create the circle or sphere that will be extruded
\f1\fs32 \cf4 \

\f0\fs17\fsmilli8667 \'a0\'a0\'a0 model.component(\cf5 "comp1"\cf4 ).geom(\cf5 "geom1"\cf4 ).create(\cf5 "wp"\cf8 +\cf4 i1, \cf5 "WorkPlane"\cf4 );
\f1\fs32 \

\f0\fs17\fsmilli8667 \'a0\'a0\'a0 model.component(\cf5 "comp1"\cf4 ).geom(\cf5 "geom1"\cf4 ).feature(\cf5 "wp"\cf8 +\cf4 i1).set(\cf5 "planetype"\cf4 , \cf5 "normalvector"\cf4 );
\f1\fs32 \

\f0\fs17\fsmilli8667 \'a0\'a0\'a0 model.component(\cf5 "comp1"\cf4 ).geom(\cf5 "geom1"\cf4 ).feature(\cf5 "wp"\cf8 +\cf4 i1).set(\cf5 "normalvector"\cf4 , 
\f2\b \cf6 new
\f0\b0 \cf4  
\f2\b \cf7 double
\f0\b0 \cf4 []\{delx, dely, delz\});
\f1\fs32 \

\f0\fs17\fsmilli8667 \'a0\'a0\'a0 model.component(\cf5 "comp1"\cf4 ).geom(\cf5 "geom1"\cf4 ).feature(\cf5 "wp"\cf8 +\cf4 i1).set(\cf5 "normalcoord"\cf4 , 
\f2\b \cf6 new
\f0\b0 \cf4  
\f2\b \cf7 double
\f0\b0 \cf4 []\{dm[k][0], dm[k][1], dm[k][2]\});
\f1\fs32 \

\f0\fs17\fsmilli8667 \'a0\'a0\'a0 model.component(\cf5 "comp1"\cf4 ).geom(\cf5 "geom1"\cf4 ).feature(\cf5 "wp"\cf8 +\cf4 i1).set(\cf5 "unite"\cf4 , 
\f2\b \cf6 true
\f0\b0 \cf4 );
\f1\fs32 \

\f0\fs17\fsmilli8667 \'a0\'a0\'a0 model.component(\cf5 "comp1"\cf4 ).geom(\cf5 "geom1"\cf4 ).feature(\cf5 "wp"\cf8 +\cf4 i1).set(\cf5 "workplane3d"\cf4 , 
\f2\b \cf6 true
\f0\b0 \cf4 );
\f1\fs32 \

\f0\fs17\fsmilli8667 \'a0\'a0\'a0 model.component(\cf5 "comp1"\cf4 ).geom(\cf5 "geom1"\cf4 ).feature(\cf5 "wp"\cf8 +\cf4 i1).geom().create(\cf5 "c"\cf8 +\cf4 i1, \cf5 "Circle"\cf4 );
\f1\fs32 \

\f0\fs17\fsmilli8667 \'a0\'a0\'a0 model.component(\cf5 "comp1"\cf4 ).geom(\cf5 "geom1"\cf4 ).feature(\cf5 "wp"\cf8 +\cf4 i1).geom().feature(\cf5 "c"\cf8 +\cf4 i1).set(\cf5 "r"\cf4 , rad1);
\f1\fs32 \

\f0\fs17\fsmilli8667 \'a0\'a0\'a0 \cf2 //model.component("comp1").geom("geom1").run();
\f1\fs32 \cf4 \

\f0\fs17\fsmilli8667 \'a0\'a0\'a0 
\f1\fs32 \

\f0\fs17\fsmilli8667 \'a0\'a0\'a0 \cf2 // Creating the coordinate points for cylinder axis
\f1\fs32 \cf4 \

\f0\fs17\fsmilli8667 \'a0\'a0\'a0 i2 \cf8 =\cf4  i2\cf8 +\cf4 1;
\f1\fs32 \

\f0\fs17\fsmilli8667 \'a0\'a0\'a0 model.component(\cf5 "comp1"\cf4 ).geom(\cf5 "geom1"\cf4 ).create(\cf5 "ls"\cf8 +\cf4 i2, \cf5 "LineSegment"\cf4 );
\f1\fs32 \

\f0\fs17\fsmilli8667 \'a0\'a0\'a0 model.component(\cf5 "comp1"\cf4 ).geom(\cf5 "geom1"\cf4 ).feature(\cf5 "ls"\cf8 +\cf4 i2).set(\cf5 "specify1"\cf4 , \cf5 "coord"\cf4 );
\f1\fs32 \

\f0\fs17\fsmilli8667 \'a0\'a0\'a0 model.component(\cf5 "comp1"\cf4 ).geom(\cf5 "geom1"\cf4 ).feature(\cf5 "ls"\cf8 +\cf4 i2).set(\cf5 "coord1"\cf4 , 
\f2\b \cf6 new
\f0\b0 \cf4  
\f2\b \cf7 double
\f0\b0 \cf4 []\{dm[k][0], dm[k][1], dm[k][2]\});
\f1\fs32 \

\f0\fs17\fsmilli8667 \'a0\'a0\'a0 model.component(\cf5 "comp1"\cf4 ).geom(\cf5 "geom1"\cf4 ).feature(\cf5 "ls"\cf8 +\cf4 i2).set(\cf5 "specify2"\cf4 , \cf5 "coord"\cf4 );
\f1\fs32 \

\f0\fs17\fsmilli8667 \'a0\'a0\'a0 model.component(\cf5 "comp1"\cf4 ).geom(\cf5 "geom1"\cf4 ).feature(\cf5 "ls"\cf8 +\cf4 i2).set(\cf5 "coord2"\cf4 , 
\f2\b \cf6 new
\f0\b0 \cf4  
\f2\b \cf7 double
\f0\b0 \cf4 []\{dm[k][3], dm[k][4], dm[k][5]\});
\f1\fs32 \

\f0\fs17\fsmilli8667 \'a0\'a0\'a0 \cf2 //model.component("comp1").geom("geom1").run();
\f1\fs32 \cf4 \

\f0\fs17\fsmilli8667 \'a0\'a0\'a0 
\f1\fs32 \

\f0\fs17\fsmilli8667 \'a0\'a0\'a0 \cf2 // sweep the ellipse/circle along the axis
\f1\fs32 \cf4 \

\f0\fs17\fsmilli8667 \'a0\'a0\'a0 model.component(\cf5 "comp1"\cf4 ).geom(\cf5 "geom1"\cf4 ).create(\cf5 "swe"\cf8 +\cf4 i2, \cf5 "Sweep"\cf4 );
\f1\fs32 \

\f0\fs17\fsmilli8667 \'a0\'a0\'a0 model.component(\cf5 "comp1"\cf4 ).geom(\cf5 "geom1"\cf4 ).feature(\cf5 "swe"\cf8 +\cf4 i2).set(\cf5 "crossfaces"\cf4 , 
\f2\b \cf6 true
\f0\b0 \cf4 );
\f1\fs32 \

\f0\fs17\fsmilli8667 \'a0\'a0\'a0 model.component(\cf5 "comp1"\cf4 ).geom(\cf5 "geom1"\cf4 ).feature(\cf5 "swe"\cf8 +\cf4 i2).set(\cf5 "includefinal"\cf4 , 
\f2\b \cf6 false
\f0\b0 \cf4 );
\f1\fs32 \

\f0\fs17\fsmilli8667 \'a0\'a0\'a0 model.component(\cf5 "comp1"\cf4 ).geom(\cf5 "geom1"\cf4 ).feature(\cf5 "swe"\cf8 +\cf4 i2).selection(\cf5 "face"\cf4 ).set(\cf5 "wp"\cf8 +\cf4 i1\cf8 +\cf5 ".c"\cf8 +\cf4 i1, 1);
\f1\fs32 \

\f0\fs17\fsmilli8667 \'a0\'a0\'a0 model.component(\cf5 "comp1"\cf4 ).geom(\cf5 "geom1"\cf4 ).feature(\cf5 "swe"\cf8 +\cf4 i2).selection(\cf5 "edge"\cf4 ).set(\cf5 "ls"\cf8 +\cf4 i2\cf8 +\cf5 "(1)"\cf4 , 1);
\f1\fs32 \

\f0\fs17\fsmilli8667 \'a0\'a0\'a0 model.component(\cf5 "comp1"\cf4 ).geom(\cf5 "geom1"\cf4 ).feature(\cf5 "swe"\cf8 +\cf4 i2).selection(\cf5 "diredge"\cf4 ).set(\cf5 "ls"\cf8 +\cf4 i2\cf8 +\cf5 "(1)"\cf4 , 1);
\f1\fs32 \

\f0\fs17\fsmilli8667 \'a0\'a0\'a0 \cf2 //model.component("comp1").geom("geom1").run();
\f1\fs32 \cf4 \

\f0\fs17\fsmilli8667 \'a0\'a0\'a0 
\f1\fs32 \

\f0\fs17\fsmilli8667 \'a0\'a0\'a0 \cf2 // Boolean subtract sweep from the block
\f1\fs32 \cf4 \

\f0\fs17\fsmilli8667 \'a0\'a0\'a0 di1 \cf8 =\cf4  di1\cf8 +\cf4 1;
\f1\fs32 \

\f0\fs17\fsmilli8667 \'a0\'a0\'a0 di2 \cf8 =\cf4  di2\cf8 +\cf4 1;
\f1\fs32 \

\f0\fs17\fsmilli8667 \'a0\'a0\'a0 model.component(\cf5 "comp1"\cf4 ).geom(\cf5 "geom1"\cf4 ).create(\cf5 "dif"\cf8 +\cf4 di1, \cf5 "Difference"\cf4 );
\f1\fs32 \

\f0\fs17\fsmilli8667 \'a0\'a0\'a0 model.component(\cf5 "comp1"\cf4 ).geom(\cf5 "geom1"\cf4 ).feature(\cf5 "dif"\cf8 +\cf4 di1).set(\cf5 "intbnd"\cf4 , 
\f2\b \cf6 false
\f0\b0 \cf4 );
\f1\fs32 \

\f0\fs17\fsmilli8667 \'a0\'a0\'a0 model.component(\cf5 "comp1"\cf4 ).geom(\cf5 "geom1"\cf4 ).feature(\cf5 "dif"\cf8 +\cf4 di1).selection(\cf5 "input"\cf4 ).set(\cf5 "dif"\cf8 +\cf4 di2);
\f1\fs32 \

\f0\fs17\fsmilli8667 \'a0\'a0\'a0 model.component(\cf5 "comp1"\cf4 ).geom(\cf5 "geom1"\cf4 ).feature(\cf5 "dif"\cf8 +\cf4 di1).selection(\cf5 "input2"\cf4 ).set(\cf5 "swe"\cf8 +\cf4 i2);
\f1\fs32 \

\f0\fs17\fsmilli8667 \'a0\'a0\'a0 
\f1\fs32 \

\f0\fs17\fsmilli8667 \'a0\'a0\'a0 \cf2 //create an ellipsoid/sphere at the end of the sweep
\f1\fs32 \cf4 \

\f0\fs17\fsmilli8667 \'a0\'a0\'a0 i3 \cf8 =\cf4  i3\cf8 +\cf4 1;
\f1\fs32 \

\f0\fs17\fsmilli8667 \'a0\'a0\'a0 model.component(\cf5 "comp1"\cf4 ).geom(\cf5 "geom1"\cf4 ).create(\cf5 "sph"\cf8 +\cf4 i3, \cf5 "Sphere"\cf4 );
\f1\fs32 \

\f0\fs17\fsmilli8667 \'a0\'a0\'a0 model.component(\cf5 "comp1"\cf4 ).geom(\cf5 "geom1"\cf4 ).feature(\cf5 "sph"\cf8 +\cf4 i3).set(\cf5 "pos"\cf4 , 
\f2\b \cf6 new
\f0\b0 \cf4  
\f2\b \cf7 double
\f0\b0 \cf4 []\{dm[k][0], dm[k][1], dm[k][2]\});
\f1\fs32 \

\f0\fs17\fsmilli8667 \'a0\'a0\'a0 model.component(\cf5 "comp1"\cf4 ).geom(\cf5 "geom1"\cf4 ).feature(\cf5 "sph"\cf8 +\cf4 i3).set(\cf5 "axis"\cf4 , 
\f2\b \cf6 new
\f0\b0 \cf4  
\f2\b \cf7 double
\f0\b0 \cf4 []\{delx, dely, delz\});
\f1\fs32 \

\f0\fs17\fsmilli8667 \'a0\'a0\'a0 model.component(\cf5 "comp1"\cf4 ).geom(\cf5 "geom1"\cf4 ).feature(\cf5 "sph"\cf8 +\cf4 i3).set(\cf5 "r"\cf4 , rad1);
\f1\fs32 \

\f0\fs17\fsmilli8667 \'a0\'a0\'a0 
\f1\fs32 \

\f0\fs17\fsmilli8667 \'a0\'a0\'a0 \cf2 // Boolean subtract ellipsoid/sphere from the block
\f1\fs32 \cf4 \

\f0\fs17\fsmilli8667 \'a0\'a0\'a0 di1 \cf8 =\cf4  di1\cf8 +\cf4 1;
\f1\fs32 \

\f0\fs17\fsmilli8667 \'a0\'a0\'a0 di2 \cf8 =\cf4  di2\cf8 +\cf4 1;
\f1\fs32 \

\f0\fs17\fsmilli8667 \'a0\'a0\'a0 model.component(\cf5 "comp1"\cf4 ).geom(\cf5 "geom1"\cf4 ).create(\cf5 "dif"\cf8 +\cf4 di1, \cf5 "Difference"\cf4 );
\f1\fs32 \

\f0\fs17\fsmilli8667 \'a0\'a0\'a0 model.component(\cf5 "comp1"\cf4 ).geom(\cf5 "geom1"\cf4 ).feature(\cf5 "dif"\cf8 +\cf4 di1).set(\cf5 "intbnd"\cf4 , 
\f2\b \cf6 false
\f0\b0 \cf4 );
\f1\fs32 \

\f0\fs17\fsmilli8667 \'a0\'a0\'a0 model.component(\cf5 "comp1"\cf4 ).geom(\cf5 "geom1"\cf4 ).feature(\cf5 "dif"\cf8 +\cf4 di1).selection(\cf5 "input"\cf4 ).set(\cf5 "dif"\cf8 +\cf4 di2);
\f1\fs32 \

\f0\fs17\fsmilli8667 \'a0\'a0\'a0 model.component(\cf5 "comp1"\cf4 ).geom(\cf5 "geom1"\cf4 ).feature(\cf5 "dif"\cf8 +\cf4 di1).selection(\cf5 "input2"\cf4 ).set(\cf5 "sph"\cf8 +\cf4 i3);
\f1\fs32 \

\f0\fs17\fsmilli8667 \'a0\'a0\'a0 
\f1\fs32 \

\f0\fs17\fsmilli8667 \'a0\'a0\'a0 \cf2 //create an ellipsoid/sphere at the other end of the sweep
\f1\fs32 \cf4 \

\f0\fs17\fsmilli8667 \'a0\'a0\'a0 i3 \cf8 =\cf4  i3\cf8 +\cf4 1;
\f1\fs32 \

\f0\fs17\fsmilli8667 \'a0\'a0\'a0 model.component(\cf5 "comp1"\cf4 ).geom(\cf5 "geom1"\cf4 ).create(\cf5 "sph"\cf8 +\cf4 i3, \cf5 "Sphere"\cf4 );
\f1\fs32 \

\f0\fs17\fsmilli8667 \'a0\'a0\'a0 model.component(\cf5 "comp1"\cf4 ).geom(\cf5 "geom1"\cf4 ).feature(\cf5 "sph"\cf8 +\cf4 i3).set(\cf5 "pos"\cf4 , 
\f2\b \cf6 new
\f0\b0 \cf4  
\f2\b \cf7 double
\f0\b0 \cf4 []\{dm[k][3], dm[k][4], dm[k][5]\});
\f1\fs32 \

\f0\fs17\fsmilli8667 \'a0\'a0\'a0 model.component(\cf5 "comp1"\cf4 ).geom(\cf5 "geom1"\cf4 ).feature(\cf5 "sph"\cf8 +\cf4 i3).set(\cf5 "axis"\cf4 , 
\f2\b \cf6 new
\f0\b0 \cf4  
\f2\b \cf7 double
\f0\b0 \cf4 []\{delx, dely, delz\});
\f1\fs32 \

\f0\fs17\fsmilli8667 \'a0\'a0\'a0 model.component(\cf5 "comp1"\cf4 ).geom(\cf5 "geom1"\cf4 ).feature(\cf5 "sph"\cf8 +\cf4 i3).set(\cf5 "r"\cf4 , rad1);
\f1\fs32 \

\f0\fs17\fsmilli8667 \'a0\'a0\'a0 
\f1\fs32 \

\f0\fs17\fsmilli8667 \'a0\'a0\'a0 \cf2 // Boolean subtract ellipsoid/sphere from the block
\f1\fs32 \cf4 \

\f0\fs17\fsmilli8667 \'a0\'a0\'a0 di1 \cf8 =\cf4  di1\cf8 +\cf4 1;
\f1\fs32 \

\f0\fs17\fsmilli8667 \'a0\'a0\'a0 di2 \cf8 =\cf4  di2\cf8 +\cf4 1;
\f1\fs32 \

\f0\fs17\fsmilli8667 \'a0\'a0\'a0 model.component(\cf5 "comp1"\cf4 ).geom(\cf5 "geom1"\cf4 ).create(\cf5 "dif"\cf8 +\cf4 di1, \cf5 "Difference"\cf4 );
\f1\fs32 \

\f0\fs17\fsmilli8667 \'a0\'a0\'a0 model.component(\cf5 "comp1"\cf4 ).geom(\cf5 "geom1"\cf4 ).feature(\cf5 "dif"\cf8 +\cf4 di1).set(\cf5 "intbnd"\cf4 , 
\f2\b \cf6 false
\f0\b0 \cf4 );
\f1\fs32 \

\f0\fs17\fsmilli8667 \'a0\'a0\'a0 model.component(\cf5 "comp1"\cf4 ).geom(\cf5 "geom1"\cf4 ).feature(\cf5 "dif"\cf8 +\cf4 di1).selection(\cf5 "input"\cf4 ).set(\cf5 "dif"\cf8 +\cf4 di2);
\f1\fs32 \

\f0\fs17\fsmilli8667 \'a0\'a0\'a0 model.component(\cf5 "comp1"\cf4 ).geom(\cf5 "geom1"\cf4 ).feature(\cf5 "dif"\cf8 +\cf4 di1).selection(\cf5 "input2"\cf4 ).set(\cf5 "sph"\cf8 +\cf4 i3);
\f1\fs32 \

\f0\fs17\fsmilli8667 \'a0\'a0\'a0 
\f1\fs32 \

\f0\fs17\fsmilli8667 \'a0 \}
\f1\fs32 \

\f0\fs17\fsmilli8667 \'a0 
\f1\fs32 \

\f0\fs17\fsmilli8667 \}\
\
\pard\pardeftab720\partightenfactor0
\cf2 //_____________________________________________________________________________________________________________________
\f1\fs32 \cf4 \

\f0\fs17\fsmilli8667 \'a0
\f1\fs32 \

\f0\fs17\fsmilli8667 \cf2 // Please do the following steps in GUI after the above steps
\f1\fs32 \cf4 \

\f0\fs17\fsmilli8667 \cf2 // Subtract second block from the first to obtain a hollow network architecture with endothelial lumen thickness.
\f1\fs32 \cf4 \

\f0\fs17\fsmilli8667 \cf2 // (Block 1 will have name diff (no: of elements in the csv file)) and
\f1\fs32 \cf4 \

\f0\fs17\fsmilli8667 \cf2 // (Block 2 will have name diff (2 x no: of elements in the csv file))
\f1\fs32 \cf4 \

\f0\fs17\fsmilli8667 \cf2 // This final diff object will be subtracted from a third block having the same dimensions as blk1 and blk2 while
\f1\fs32 \cf4 \

\f0\fs17\fsmilli8667 \cf2 // retaining the subtracted objects. 
\f1\fs32 \cf4 \

\f0\fs17\fsmilli8667 \cf2 // We will have interstitial space, vessel network, and its endothelial lumen thickness as three selectable domains
\f1\fs32 \cf4 \

\f0\fs17\fsmilli8667 \cf2 \'a0
\f1\fs32 \cf4 \

\f0\fs17\fsmilli8667 \cf2 /_____________________________________________________________________________________________________________________
\f1\fs32 \cf4 \

\f0\fs17\fsmilli8667 \cf2 \'a0
\f1\fs32 \cf4 \

\f0\fs17\fsmilli8667 \cf2 // Add physics, material properties, boundary conditions, and mesh the system in GUI
\f1\fs32 \cf4 \

\f0\fs17\fsmilli8667 \cf2 // IMPORTANT: Meshing may give errors, which needs correction manually or use AI based mesh generators to reduce errors
\f1\fs32 \cf4 \

\f0\fs17\fsmilli8667 \cf2 \'a0
\f1\fs32 \cf4 \

\f0\fs17\fsmilli8667 \cf2 // After running solve we can use the below codes to extract results or use GUI commands to visualize the results:
\f1\fs32 \cf4 \

\f0\fs17\fsmilli8667 \cf2 \'a0
\f1\fs32 \cf4 \

\f0\fs17\fsmilli8667 \cf2 //_____________________________________________________________________________________________________________________
\f1\fs32 \cf4 \

\f0\fs17\fsmilli8667 \cf2 \'a0
\f1\fs32 \cf4 \
\pard\pardeftab720\partightenfactor0
\cf4 \
}